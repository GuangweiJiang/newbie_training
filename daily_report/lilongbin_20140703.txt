Today I analysised how an application call our char device drivers in the kernel.
First of all, we should register the char device driver into the cdev list of the kernel. The complete process maybe programming the file operations such as open,read, write and ioctl; and then use the function cev_init to initialize the cdev structure, that is evaluating the address of file_operations to ops (an element of the cdev structure); at last, using cdev_add to register the cdev of device into the cdev list of the kernel. And now, the device driver is installed into the kernel.
When we use the open function of the application, the open will call a function defined in the C library, the C library's function will cause a soft irq and the corresponding system call number will be stored in the register. The sys_open in the sys_call_table will be called according to the system call number. Then sys_open will get the device number via inode->i_rdev, and find device driver's cdev with file operations have registered in the kernel cdev list in order to the device number for the index; evaluating the device driver's cdev to the inode->i_cdev for caches; creating struct file, evaluating the driver's cdev to file->f_op, then the open function of the device driver will be called finally.
In the process, the file structure is created by the kernel, it's used to describe the attribution of the device file. The inode structure is used by the kernel internally to represent files.
