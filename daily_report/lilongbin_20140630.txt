I have learnt that device number registration is just the first of many tasks that driver code must carry out. Most of the fundamental driver operations involve three important kernel data structures, called file_operations, file, and inode.
The file_operations structure is how a char driver sets up connections between our driver's operations and device numbers. A file_operations structure or a pointer to one is called fops. Each field in the structure must point to the function in the driver that implements a specific operation, or be left NULL for unsupported operations.
The struct file, defined in <linux/fs.h>, is a kernel structure that never appears in user programs. The file structure represents an open file. It is created by the kernel on open and is passed to any function that operates on the file, until the last close. File refers to the structure and filp to pointer to the structure. struct file_operations *f_op is the operations associated with the file. The kernel assigns the pointer as part of its implementation of open and then reads it when it needs to dispatch any operations. Private_data is a useful resource for preserving state information across system calls.
The inode structure is used by the kernel internally to represent files. Therefore, it is different from the file structure that represents an open file descriptor. There can be numerous file structures representing multiple open descriptions on a single file, but they all point to a single inode structure.
In summary, We use the function alloc_chrdev_region or register_chrdev_region to register a device number, use the function cdev_init to set up connections between struct file_operations fops and struct cdev; and finally, We use the function cdev_add to register the fops and device number to the kernel cdev list.

